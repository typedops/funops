<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TypedOps</title>
    <link>http://typedops.github.io</link>
    <atom:link href="http://typedops.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <description>Tutorials and code experiments about using types to build better infrastructure</description>
    <language>en-us</language>
    <pubDate>Thu, 07 Jul 2016 13:32:32 -0500</pubDate>
    <lastBuildDate>Thu, 07 Jul 2016 13:32:32 -0500</lastBuildDate>

    
      <item>
        <title>The Unreasonable Effectiveness of Reasoning: Eliminating Bottom</title>
        <link>http://typedops.github.io/tutorials/2016/05/25/unreasonable-effectiveness-of-reasoning-understanding-bottom.html</link>
        <pubDate>Wed, 25 May 2016 19:50:00 -0500</pubDate>
        <author>Susan Potter</author>
        <description>&lt;p&gt;This article provides a simple code-level case study to understand
how two functional programming libraries have made different trade-offs. We
explore related API-level design choices in a neutral language (Scala) where
we consider the ability of the consumer of the API to reason equationally
about it. We demonstrate that focusing on eliminating bottom yields
more &lt;em&gt;reasonable&lt;/em&gt; (equationally) APIs.&lt;/p&gt;

&lt;h2 id=&quot;background-mathematical-bottom-&quot;&gt;Background: (Mathematical) Bottom (⊥)&lt;/h2&gt;

&lt;p&gt;Wikipedia states this as the definition:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In type theory, a theory within mathematical logic, the bottom type is the
type that has no values. It is also called the zero or empty type, and is
sometimes denoted with falsum (⊥).&lt;/p&gt;

  &lt;p&gt;A function whose return type is bottom cannot return any value. In the
Curry–Howard correspondence, the bottom type corresponds to falsity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In lay person’s terms (my own words, not formal at all):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;bottom (in mathematics/type theory) represents any &lt;em&gt;false&lt;/em&gt; situation where
you can no longer use equational reasoning. E.g. any time you raise an
exception that unwinds the stack, or a system error is raised from the
bowels of the runtime, you have unterminated functions, or you otherwise
inflict the operating environment your program runs within with an unspoken
side effect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Real world bottom:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;returning &lt;code&gt;null&lt;/code&gt; (Java, Scala), &lt;code&gt;nil&lt;/code&gt; (Ruby), &lt;code&gt;None&lt;/code&gt; (Python), etc.&lt;/li&gt;
  &lt;li&gt;throwing/raising an exception&lt;/li&gt;
  &lt;li&gt;non-terminating functions (a function that will never normally return
unless it encounters an exception); this is needed for building long
running servers or operating systems.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Bottom_type&lt;/li&gt;
  &lt;li&gt;https://wiki.haskell.org/Bottom&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;implications&quot;&gt;Implications&lt;/h3&gt;

&lt;p&gt;(Pure) Functional programming is predicated on proven logic results from the
lambda calculus. Any time your code or other dependencies return a
&lt;em&gt;“bottom”&lt;/em&gt; value from a function you have violated the contract that allows
you to reason mathematically about your code. In truly exceptional cases
this is necessary to have an operationally well-behaved software in the real
world. Using exceptions for control flow is not &lt;em&gt;truly exceptional&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One &lt;em&gt;truly exceptional&lt;/em&gt; example might be a runtime exception to denote an out
of memory system condition was met. In such a case, what can your application
reasonably do to counter this problem? I would argue nothing in most
runtimes, except maybe log it and exit if that is even possible.&lt;/p&gt;

&lt;p&gt;Knowing how, when and what to reason about in your codebase is the key to
applying the lambda calculus to your software in the real world. Even
Haskellers have portions of their code they cannot equationally reason about
to cater for their real world operational needs. Knowing the vulnerabilities
in the ability to reason about your code is key building more well reasoned
software.&lt;/p&gt;

&lt;p&gt;Limiting the surface area where &lt;em&gt;bottom&lt;/em&gt; may arise in your code reduces the
possibility of wide classes of runtime bugs albeit at &lt;em&gt;possible&lt;/em&gt; (not always)
costs of more resource usage.&lt;/p&gt;

&lt;h2 id=&quot;case-study-system-environment-variable-lookup&quot;&gt;Case Study: System Environment Variable Lookup&lt;/h2&gt;

&lt;p&gt;Doing something as simple as looking up an environment variable yields
&lt;em&gt;bottom&lt;/em&gt; in OCaml but not in Haskell/GHC. Let’s compare approaches.&lt;/p&gt;

&lt;h3 id=&quot;ocaml-4010&quot;&gt;OCaml 4.01.0&lt;/h3&gt;

&lt;p&gt;The version of OCaml can likely vary from this version to yield the
same results, but I have only tested with 4.01.0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[git:master?+] spotter@redhorn ~/src/work/root
$ ocaml
        OCaml version 4.01.0

# open Sys;;
# getenv;;
- : string -&amp;gt; string = &amp;lt;fun&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The OCaml type is simple (&lt;code&gt;string -&amp;gt; string&lt;/code&gt;): given a &lt;code&gt;string&lt;/code&gt; the function
returns a &lt;code&gt;string&lt;/code&gt;. Of course, it is side effecting as we will see below.
The simplicity comes at a cost because we lost the ability to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;describe the program’s logic separately from when it is
performed/evaluated. Once you call this function a side effect is imposed
on the operating environment. In this case we are just querying the system
environment which may not have negative impact, but in many other cases it
may, e.g. setting variable value in system environment.&lt;/li&gt;
  &lt;li&gt;denote by a specific return value that the environment variable is not set.
The way that OCaml caters for this case is by raising an exception that
unwinds the stack. i.e. producing a bottom value. This is not represented
to the caller in the type signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;haskellghc-710x&quot;&gt;Haskell/GHC 7.10.x+&lt;/h3&gt;

&lt;p&gt;This code will likely work in many prior versions of GHC but I have only
tested on 7.10.3.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ghci
GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude&amp;gt; import System.Posix
Prelude System.Posix&amp;gt; :t getEnv
getEnv :: String -&amp;gt; IO (Maybe String)
Prelude System.Posix&amp;gt; :q
Leaving GHCi.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type signature of getting the value of an environment variable in
&lt;code&gt;System.Posix&lt;/code&gt; module is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-hs&quot;&gt;String -&amp;gt; IO (Maybe String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In English this translates to: &lt;em&gt;given a String we produce a program in the
&lt;code&gt;IO&lt;/code&gt; context where when performed will return a &lt;code&gt;Maybe String&lt;/code&gt; value.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Notice here that the module &lt;code&gt;System.Posix&lt;/code&gt; provides a function that does two
things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wraps the result into an IO context so that the intended program can be
represented as an &lt;code&gt;IO&lt;/code&gt; value to separate it from the performance/execution
of the program (a core tenet of referential transparency or ‘purity’).&lt;/li&gt;
  &lt;li&gt;ensures that the inner value describes the context that no environment
variable setting is a valid value in the domain of environment variables.
i.e. what we are saying is that in a system environment if a key is not
present, we return a value that signifies that back to the caller as an
explicit value. In the world of environment variable retrieving we probably
don’t care about returning an error value that describes why a &lt;code&gt;String&lt;/code&gt;
value wasn’t returned as there are so few reasons it would likely not be
interesting to the caller of the function. However, in some domains we
would provide a function with the type: &lt;code&gt;String -&amp;gt; IO (Either e String)&lt;/code&gt;
where &lt;code&gt;e&lt;/code&gt; is a coproduct/sum type that describes the possible errors
possible in the context of the function.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;Usage of the respective APIs.&lt;/p&gt;

&lt;h3 id=&quot;ocaml&quot;&gt;OCaml&lt;/h3&gt;

&lt;p&gt;Follow along in your &lt;code&gt;ocaml&lt;/code&gt; REPL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;# getenv &quot;HOME&quot;
  ;;
- : string = &quot;/home/spotter&quot;
# getenv &quot;HOME2&quot;
  ;;
Exception: Not_found.
^D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ouch! We do not have the ability to encapsulate the effects and decide &lt;em&gt;when&lt;/em&gt;
to perform them without the context in the return type (&lt;code&gt;IO a&lt;/code&gt; in the
Haskell/GHC case). We also don’t receive a type expressing the optionality
of the result which forces &lt;em&gt;bottom&lt;/em&gt; be returned.&lt;/p&gt;

&lt;h3 id=&quot;haskell&quot;&gt;Haskell&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Prelude System.Posix&amp;gt; getEnv &quot;HOME&quot;
Just &quot;/home/spotter&quot;
it :: Maybe String
Prelude System.Posix&amp;gt; getEnv &quot;HOME2&quot;
Nothing
it :: Maybe String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we are in the GHCi (REPL/interactive shell) we are essentially
performing the &lt;code&gt;IO&lt;/code&gt; action at the same time we call it, but that is only due
to calling within the REPL without using &lt;code&gt;let&lt;/code&gt;. Below we use the same API to
get an &lt;code&gt;IO&lt;/code&gt; action (aka &lt;em&gt;program&lt;/em&gt;) which we can combine with other &lt;code&gt;IO&lt;/code&gt;
actions to produce a new and improved program in the &lt;code&gt;IO&lt;/code&gt; context to later
perform/execute it.&lt;/p&gt;

&lt;p&gt;Follow along in your own &lt;code&gt;ghci&lt;/code&gt; REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-hs&quot;&gt;Prelude&amp;gt; import System.Posix
Prelude System.Posix&amp;gt; let a0 = getE
getEffectiveGroupID   getEffectiveUserName  getEnvDefault         getEnvironmentPrim
getEffectiveUserID    getEnv                getEnvironment
Prelude System.Posix&amp;gt; let a0 = getEnv &quot;HOME&quot;
Prelude System.Posix|
a0 :: IO (Maybe String)
Prelude System.Posix&amp;gt; :t a0
a0 :: IO (Maybe String)
Prelude System.Posix&amp;gt; let a1 = getEnv &quot;HOME2&quot;
Prelude System.Posix|
a1 :: IO (Maybe String)
Prelude System.Posix&amp;gt; :t a1
a1 :: IO (Maybe String)
Prelude System.Posix System.IO.Unsafe&amp;gt; let a2 = a0 &amp;gt;&amp;gt;= putStrLn . printMaybeS &amp;gt;&amp;gt;= const a1 &amp;gt;&amp;gt;=
putStrLn . printMaybeS
a2 :: IO ()
Prelude System.Posix System.IO.Unsafe&amp;gt; unsafePerformIO a2
/home/spotter
(unset)
()
it :: ()
Prelude System.Posix&amp;gt; :quit
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;trade-offs&quot;&gt;Trade-offs&lt;/h2&gt;

&lt;p&gt;Let’s look at each of these API choices in Scala (a neutral language):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;/*
 * Using Scalaz Effect v7.2.1:
 *    &quot;org.scalaz&quot; %% &quot;scalaz-effect&quot; % &quot;7.2.1&quot;
 */
import scalaz._, Scalaz._
// import scalaz._
// import Scalaz._

import scalaz.effect._
// import scalaz.effect._

case class EnvError(message: String)
// defined class EnvError

object SysEnv0 {
  /**
    * This function is side effecting:
    * We do not separate performance of the effects from
    * building the program in the context nor does it denote
    * an unset environment variable in any meaningful way (it
    * returns a null value if unset) which is another form of
    * bottom. This yields code littered with null checks diluting
    * application codebase where business logic should be central
    * focus.
    */
  def getEnv0(key: String): String =
    sys.env.get(key).getOrElse(null)

  /**
    * This function is side effecting:
    * We do not separate performance of the effects from
    * building the program in the context nor do we represent
    * optionality of the return type in any meaningful way, this
    * definition uses empty string to denote an unset environment
    * variable which is not a unique value but is not a bottom value
    * case as in the first definition. However, we lose the ability
    * to tell the case where the environment variable is not set
    * apart from the case where the environment variable was set to
    * a value of the empty string. This may not be interesting for
    * your needs, so you get to decide.
    */
  def getEnv1(key: String): String =
    sys.env.get(key).getOrElse(&quot;&quot;)

  /**
    * This function is side effecting:
    * We still do not separate performance of the effects from
    * building the program as a value and we denote the case of
    * an environment variable name not set with a runtime exception
    * which is another form of bottom value returned.
    */
  def getEnv2(key: String): String =
    sys.env.get(key).getOrElse(throw new RuntimeException(s&quot;Key ${key} not found&quot;))

  /**
    * This function is side effecting:
    * We are not yet separating program as a value that can be
    * combined with other programs in the same context using
    * simple and common combinators, but in this type signature
    * we explicitly denote the optionality of the returned value
    * for the case where the environment variable is not set.
    */
  def getEnv3(key: String): Option[String] =
    sys.env.get(key)

  /**
    * This function is effectful:
    * We are building a program as a value in the IO context. We also
    * denote the optionality of the underlying program&#39;s return type
    * with Option[String]. These are all good things from the perspective
    * of equationally reasoning about your code.
    */
  def getEnv4(key: String): IO[Option[String]] =
    IO { sys.env.get(key) }

  /**
    * This function is effectful:
    * We are building a program as a value in the IO context to be
    * performed at a later time once it is combined with other IO
    * programs (or values representing programs that can be translated
    * to the IO context). We also provide more context in the specific
    * error case where the environment variable is not set with a message
    * that shows a message containing the key name. This could be made more
    * explicit if we passed the value constructor for the EnvError two
    * arguments where one is the name of the environment variable and the
    * other is the message.
    */
  def getEnv5(key: String): IO[EnvError \/ String] =
    IO { sys.env.get(key) \/&amp;gt; EnvError(s&quot;Couldn&#39;t find key ${key}.&quot;) }
}
// defined object SysEnv0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By wrapping your return values inside effects/contexts you do require more
from the consumer of your API to get at the “happy path” result, but you
provide much more control and/or context for the consumer of your API with
additional type safety that can help in refactoring your code base. In the
non-happy path cases the extra control and context is a positive since
you would need to wrap exception handling code around the call site for
each API use.&lt;/p&gt;

&lt;p&gt;Depending on your programming environment and requirements you may need to
weigh the memory and CPU cycle costs of this extra wrapping. Make sure you
measure whether this impacts your system negatively before prematurely
optimizing and relatively prioritize the importance of higher-level
abstraction and control over specific performance characteristics based
on application need.&lt;/p&gt;

&lt;p&gt;There is a dirty little secret: you don’t have to stop at &lt;code&gt;IO&lt;/code&gt;. In fact,
it is typically preferrable to wrap/layer into more specific contexts with
limited operations/constructors and then translate to the &lt;code&gt;IO&lt;/code&gt; context at the
end before performing/executing the &lt;code&gt;IO&lt;/code&gt; program. You can find out more by
reviewing literature (and possibly future posts on this blog) on free monads
or extensible effects with the effect monad (sometimes referred to as &lt;code&gt;Eff&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The moral of the story is you must remember the ability to reason about the
APIs you design are influenced by how much you make an effort to eliminate
bottom.&lt;/p&gt;

&lt;p&gt;As the API designer you get to decide where to draw the line. It is
prudent to consider the usability of your API as a consumer. If
your library/code does not need to be highly tuned you can always provide a
simpler API on top of better defined (from an equational reasoning
perspective) functions to fit more consumer needs. Let’s look below to
see what this could look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;object SysEnv1 {
  def getEnv0(key: String): String =
    try {
      getEnv2(key)
    } catch {
      case re: RuntimeException =&amp;gt; null // this is crazy, don&#39;t do this.
    }

  def getEnv1(key: String): String =
    getEnv0(key) match {
      case null =&amp;gt; &quot;&quot;
      case x    =&amp;gt; x
    }

  def getEnv2(key: String): String =
    getEnv3(key) match {
      case Some(x) =&amp;gt; x
      case None =&amp;gt; throw new RuntimeException(s&quot;Key ${key} not found.&quot;)
    }

  def getEnv3(key: String): Option[String] =
    getEnv4(key).unsafePerformIO

  def getEnv4(key: String): IO[Option[String]] =
    getEnv5(key).map(_.toOption)

  def getEnv5(key: String): IO[EnvError \/ String] =
    IO { sys.env.get(key) \/&amp;gt; EnvError(s&quot;Couldn&#39;t find key ${key}.&quot;) }
}
// defined object SysEnv1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cheers and happy reasoning.&lt;/p&gt;

&lt;h3 id=&quot;thank-you&quot;&gt;Thank you!&lt;/h3&gt;

&lt;p&gt;I would like to thank the following non-functional programmers for reviewing
a rough draft of this post for flow and cohesiveness:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/randomfrequency&quot;&gt;@randomfrequency&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/PeterCaswell&quot;&gt;Peter Caswell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Extending Syntax in Scala</title>
        <link>http://typedops.github.io/tutorials/2015/11/05/extending-syntax.html</link>
        <pubDate>Thu, 05 Nov 2015 13:29:00 -0600</pubDate>
        <author>Susan Potter</author>
        <description>&lt;p&gt;Yesterday I learned something really cool. In Idris I can just do this
to extend the syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-idris&quot;&gt;syntax [ma] &quot;?&quot; [a] = fromMaybe a ma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;fromMaybe&lt;/code&gt; is from the &lt;code&gt;Prelude.Maybe&lt;/code&gt; module which has the type
signature: &lt;code&gt;fromMaybe : Lazy a -&amp;gt; Maybe a -&amp;gt; a&lt;/code&gt; so now I can do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-idris&quot;&gt;idris&amp;gt; (Just 88) ? 77
88 : Integer

idris&amp;gt; Nothing ? 77
77 : Integer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So today we will see how much of a challenge it will be to do this in Scala.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hint: It might be a little more work, but doable.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;

&lt;p&gt;We will start out defining the sum type &lt;code&gt;Maybe&lt;/code&gt; with data constructors &lt;code&gt;Nowt&lt;/code&gt;
(same as &lt;code&gt;Nothing&lt;/code&gt; in Idris) and &lt;code&gt;Just&lt;/code&gt; which wraps an underlying &lt;code&gt;A&lt;/code&gt; value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; sealed abstract class Maybe[A]
defined class Maybe

scala&amp;gt; case class Just[A](a: A) extends Maybe[A]
defined class Just

scala&amp;gt; case class Nowt[A]() extends Maybe[A]
defined class Nowt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we just have to define the &lt;code&gt;fromMaybe[A]&lt;/code&gt; decorator. We can do this in the
companion object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; object Maybe {
     |   def fromMaybe[A](a: A)(ma: Maybe[A]): A = ma match {
     |     case Just(x) =&amp;gt; x
     |     case Nowt() =&amp;gt; a
     |   }
     | }
defined object Maybe
warning: previously defined class Maybe is not a companion to object Maybe.
Companions must be defined together; you may wish to use :paste mode for this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have what was already provided by Idris in the Prelude, therefore so
far, we have been setting up our Scala code to mimick what we had in Idris.
(Note: we could have also used &lt;code&gt;Option[A]&lt;/code&gt; and related &lt;code&gt;getOrElse&lt;/code&gt; method
instead of the above).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; object Maybe { self =&amp;gt; /* Note: newly added reference to outer object */
     |   def fromMaybe[A](a: A)(ma: Maybe[A]): A = ma match {
     |     case Just(x) =&amp;gt; x
     |     case Nowt() =&amp;gt; a
     |   }
     | 
     |   /* Helpers for value construction */
     |   def apply[A](a: A): Maybe[A] = if (a == null) Nowt() else Just(a)
     |   def nowt[A]: Maybe[A] = Nowt()
     |   def just[A](a: A) = Maybe(a)
     | 
     |   /* Newly added code */
     |   implicit class MaybeOps[A](val ma: Maybe[A]) extends AnyVal {
     |     def ?(a: A): A = self.fromMaybe(a)(ma)
     |   }
     | }
defined object Maybe
warning: previously defined class Maybe is not a companion to object Maybe.
Companions must be defined together; you may wish to use :paste mode for this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can test that we can use the new syntax (&lt;code&gt;?&lt;/code&gt; operator) the way we want:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; object Main extends App {
     |   import Maybe._
     | 
     |   val mint1 = just(30)
     |   val mint2 = nowt[Int]
     | 
     |   println(mint1 ? 60)
     |   println(mint2 ? 60)
     | }
defined object Main

scala&amp;gt; Main.main(Array.empty[String])
30
60
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We added decoration method &lt;code&gt;?&lt;/code&gt; to &lt;code&gt;Maybe[A]&lt;/code&gt; values by importing the companion
object implicit value class &lt;code&gt;MaybeOps[A]&lt;/code&gt; definition into scope.&lt;/p&gt;

&lt;p&gt;To recap we only need to add the following code to &lt;em&gt;provide&lt;/em&gt; the syntax
within the companion object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;  implicit class MaybeOps[A](val ma: Maybe[A]) extends AnyVal {
    def ?(a: A): A = self.fromMaybe(a)(ma)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the consuming side we just need to import the top-level companion object
content into scope like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;  import Maybe._
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For bonus points, we added a couple of smart value constructors in the
companion object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt;   def apply[A](a: A): Maybe[A] = if (a == null) Nowt() else Just(a)
apply: [A](a: A)Maybe[A]

scala&amp;gt;   def nowt[A]: Maybe[A] = Nowt()
nowt: [A]=&amp;gt; Maybe[A]

scala&amp;gt;   def just[A](a: A) = Maybe(a)
just: [A](a: A)Maybe[A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes consuming code for constructing &lt;code&gt;Maybe[A]&lt;/code&gt; values simpler
with appropriate type inference (i.e. we want &lt;code&gt;Maybe[A]&lt;/code&gt; to always
be inferred not &lt;code&gt;Just[A]&lt;/code&gt; or &lt;code&gt;Nowt[A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If we had not added these value constructors or not used them we
would have this problem on our hands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt;   val mint1 = Just(30)
mint1: Just[Int] = Just(30)

scala&amp;gt;   val mint2 = Nowt[Int]
mint2: Nowt[Int] = Nowt()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Look at the types inferred by Scala. In some scenarios, this might
give you problems.&lt;/p&gt;

&lt;h2 id=&quot;review&quot;&gt;Review&lt;/h2&gt;

&lt;p&gt;Scala provides a way to extend syntax in a few different ways. Above we
showed one way where we can still uphold the level of typesafety that our API
requires yet still offer some level of syntax/operator decoration or addition.&lt;/p&gt;

&lt;p&gt;How could you effectively enhance your operations management libraries with
the technique outlined above?&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Why Use Types?</title>
        <link>http://typedops.github.io/tutorials/2015/10/09/why-use-types.html</link>
        <pubDate>Fri, 09 Oct 2015 05:50:00 -0500</pubDate>
        <author>Susan Potter</author>
        <description>&lt;p&gt;Types are one of the most mainstream and widespread applied formal methods
in software engineering industry today. Yet I have met many accomplished and
experienced practitioners in our field who do not know how to effectively use
types, even in lanuages they can leverage well for this.&lt;/p&gt;

&lt;p&gt;This tutorial is an attempt to show step by step an iterative approach to
transforming what I would consider an ill-typed API (a form I see very often
in operations or infrastructure code) towards a more type-expressive API
which eliminates a large set of invalid values from ever being constructed in
the first place.&lt;/p&gt;

&lt;p&gt;This will be the basis for future tutorials that will follow, putting into
practice more structural typed techniques often used in typed functional
programming. My claim here is that pairing a half decent type system that
can express many valid constructions of values (and eliminate many invalid
constructions) with functional programming principles and abstractions we can
build a solid core of a working library or executable. It will allow us to
reason about our code such that we can extend it in ways we previously thought
unimaginable without much heavy lifting (after the initial plumbing work). We
will start to see evidence for this claim in this tutorial post and subsequent
tutorials will build upon this foundation to supply more evidence as we go
along on our journey.&lt;/p&gt;

&lt;h2 id=&quot;to-the-cloud-and-beyond&quot;&gt;To The Cloud And Beyond&lt;/h2&gt;

&lt;p&gt;Let’s start out with a simple example. We need to model VPCs and Subnets in
AWS:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; case class Vpc(
     |   cidrBlock: String,
     |   region: String,
     |   dhcpOptionsId: String,
     |   instanceTenancy: String,
     |   isDefault: Boolean)
defined class Vpc

scala&amp;gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: String,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s use these definition to construct values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; val region = &quot;us-west-14&quot;
region: String = us-west-14

scala&amp;gt; val vpc = Vpc(&quot;10.0.0.0/16&quot;, region, null, &quot;dedicated&quot;, false)
vpc: Vpc = Vpc(10.0.0.0/16,us-west-14,null,dedicated,false)

scala&amp;gt; val subnet = Subnet(&quot;10.10.16.0/24&quot;, &quot;sg-123456&quot;, s&quot;${region}b&quot;, false, false)
subnet: Subnet = Subnet(10.10.16.0/24,sg-123456,us-west-14b,false,false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few problems in just this simple usage of these simple classes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There is no region named &lt;code&gt;us-west-14&lt;/code&gt; and the derived availability zone
value is also invalid.&lt;/li&gt;
  &lt;li&gt;A &lt;code&gt;null&lt;/code&gt; was given for &lt;code&gt;dhcpOptionsId&lt;/code&gt; argument but the behavior of various
utilities using these types is unknown when this happens as we don’t know
if they will actually handle &lt;code&gt;null&lt;/code&gt;’s properly with defensive programming.&lt;/li&gt;
  &lt;li&gt;We might have fat fingered the &lt;code&gt;instanceTenancy&lt;/code&gt;, this time we didn’t, but
who knows when everything is just of type &lt;code&gt;String&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We have no idea if the given &lt;code&gt;cidr&lt;/code&gt; block arguments to either &lt;code&gt;Vpc&lt;/code&gt; or
&lt;code&gt;Subnet&lt;/code&gt; are valid since we just expect a &lt;code&gt;String&lt;/code&gt; representing a CIDR.&lt;/li&gt;
  &lt;li&gt;We have no idea if the string id for DHCP options or VPC are referring to
identifiers of the right kind or not.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We started with such a simple API and already have numerous issues with just
using weak types in our data type definitions.&lt;/p&gt;

&lt;p&gt;Now let’s toughen up these types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; // We build a sum type (also called coproduct in some literature)
     | // This is a kind of algebraic data type that represents a logical OR
     | sealed trait Region
defined trait Region

scala&amp;gt; case object UsWest1 extends Region
defined object UsWest1

scala&amp;gt; case object UsWest2 extends Region
defined object UsWest2

scala&amp;gt; case object UsEast1 extends Region
defined object UsEast1

scala&amp;gt; case object EuWest1 extends Region
defined object EuWest1

scala&amp;gt; // Another sum type here for zone *inside* of a region
     | sealed trait Zone
defined trait Zone

scala&amp;gt; case object A extends Zone
defined object A

scala&amp;gt; case object B extends Zone
defined object B

scala&amp;gt; case object C extends Zone
defined object C

scala&amp;gt; // This is a product type (a dressed up N-tuple)
     | // This is another kind of algebraic data type representing logical AND
     | case class AvailabilityZone(region: Region, zone: Zone)
defined class AvailabilityZone

scala&amp;gt; // A sum type to represent the notion of instance tenancy, I am sure I am
     | // missing possible data constructors (the case objects/classes that extend
     | // from the base class, in this case +InstanceTenancy+).
     | sealed trait InstanceTenancy
defined trait InstanceTenancy

scala&amp;gt; case object Dedicated extends InstanceTenancy
defined object Dedicated

scala&amp;gt; case object Default extends InstanceTenancy
defined object Default

scala&amp;gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[String],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&amp;gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have some provisioning logic that picks the appropriate AWS
credentials when using specific regions vs others:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; // we are just mocking out this function for now and not *doing* anything yet
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region == &quot;us-west-1&quot;) &quot;vpc-123456&quot; else &quot;vpc-654321&quot;
&amp;lt;console&amp;gt;:23: warning: Region and String are unrelated: they will most likely never compare equal
         if (vpc.region == &quot;us-west-1&quot;) &quot;vpc-123456&quot; else &quot;vpc-654321&quot;
                        ^
provisionVpc: (vpc: Vpc)String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a problem. The &lt;code&gt;==&lt;/code&gt; is always false, but shouldn’t it be a
compiler error instead? In Scala, &lt;code&gt;==&lt;/code&gt; takes on the same semantics as
the same operator in Java and thus will always compile even when you
are comparing the value of a different type.&lt;/p&gt;

&lt;p&gt;Thankfully in libraries like &lt;code&gt;cats&lt;/code&gt; or &lt;code&gt;scalaz&lt;/code&gt; (we will be using
&lt;code&gt;cats&lt;/code&gt; in these examples) we can use a type safe equality operator
like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; import cats._, cats.std.all._, cats.syntax.all._
import cats._
import cats.std.all._
import cats.syntax.all._

scala&amp;gt; implicit val regionEquality = new Eq[Region] {
     |   def eqv(r1: Region, r2: Region): Boolean = r1 == r2
     | }
regionEquality: cats.Eq[Region] = $anon$1@7193745d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It may not seem like we have accomplished much here except that when we use
&lt;code&gt;===&lt;/code&gt; (the typesafe equality operator) our code will not compile when we
check different types for equality:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; // Now reimplement provisionVpc (but this does not compile, which is what we
     | // want!!!)
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === &quot;us-west-1&quot;) &quot;vpc-123456&quot; else &quot;vpc-654321&quot;
&amp;lt;console&amp;gt;:34: error: type mismatch;
 found   : String(&quot;us-west-1&quot;)
 required: Region
         if (vpc.region === &quot;us-west-1&quot;) &quot;vpc-123456&quot; else &quot;vpc-654321&quot;
                            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following will compile and is exactly what we want in our case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; // Now reimplement provisionVpc where types on either side of === match such
     | // that this now compiles but also the logic behaves as we expect and can
     | // reason about.
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === UsWest1) &quot;vpc-123456&quot; else &quot;vpc-654321&quot;
provisionVpc: (vpc: Vpc)String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we could still improve the constituent types of the &lt;code&gt;Vpc&lt;/code&gt; and &lt;code&gt;Subnet&lt;/code&gt;
product types further such as accepting a &lt;code&gt;Cidr&lt;/code&gt; type for the CIDR block
given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; import spire.math._, spire.implicits._
import spire.math._
import spire.implicits._

scala&amp;gt; // Note: UByte is from spire. It is the most natural type that represents
     | // what we want below without defining a low level type ourselves.
     | // Let me know if I missed something from the standard library that isn&#39;t
     | // Byte.
     | 
     | sealed trait IpAddress
defined trait IpAddress

scala&amp;gt; object IpAddress {
     |   private case class Ipv4(a: UByte, b: UByte, c: UByte, d: UByte) extends IpAddress
     |   // TODO: implement Ipv6 when needed
     | 
     |   def apply(a: UByte, b: UByte, c: UByte, d: UByte): IpAddress =
     |     Ipv4(a, b, c, d)
     | }
defined object IpAddress
warning: previously defined trait IpAddress is not a companion to object IpAddress.
Companions must be defined together; you may wish to use :paste mode for this.

scala&amp;gt; // We want an unsigned byte to represent the Prefix (at least for now)
     | type Prefix = UByte
defined type alias Prefix

scala&amp;gt; def prefix(p: UByte): Option[Prefix] =
     |   if (p &amp;lt;= UByte(32) &amp;amp;&amp;amp; p &amp;gt;= UByte(0)) Some(p) else None
prefix: (p: spire.math.UByte)Option[Prefix]

scala&amp;gt; case class Cidr(ip: IpAddress, prefix: Prefix)
defined class Cidr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far we have addressed 1 through 4 of the list of problems we identified
above. Let’s recap what we did:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We encoded the notion of region as a sum type and changed the type used
from &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Region&lt;/code&gt;. We have eliminated a large number of possible
invalid values from being used in it’s place such that non-existent AWS
regions referenced would not even compile.&lt;/li&gt;
  &lt;li&gt;We encoded in our type signature for the &lt;code&gt;Vpc&lt;/code&gt; product type (case class)
that we do not require DHCP options identifier to construct a valid &lt;code&gt;Vpc&lt;/code&gt;
value. This will inform implementers of functions that use this value that
this field is an optional value so they can plan accordingly.&lt;/li&gt;
  &lt;li&gt;We encoded the notion of instance tenancy as a sum type and switched from
using a &lt;code&gt;String&lt;/code&gt; to represent the possible values of it to this new type,
&lt;code&gt;InstanceTenancy&lt;/code&gt;. The compiler will not catch any fat fingering we may
have made. Think of the potential troubleshooting and debugging time we
gained back from this simple act.&lt;/li&gt;
  &lt;li&gt;We have encoded a more meaningful representation for CIDR values that will
limit the possible values to valid basic constructions. A &lt;code&gt;String&lt;/code&gt; value
gives us know structure to verify and the validation logic on a &lt;code&gt;String&lt;/code&gt;
value for the CIDR case would be error prone and complex without decomposing
into the structural elements of the value in the first place. Even using
regular expressions to validate a &lt;code&gt;String&lt;/code&gt; representing a CIDR requires us
to decompose the value into its elements (plus it might not be very
efficient but that is a secondary concern). :)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now we can tackle referential consistency of our string ids via a construct
in Scala called value classes. This allows us to enforce type safety at
compile-time without the runtime allocation overhead.&lt;/p&gt;

&lt;p&gt;For our purposes we will wrap up &lt;code&gt;String&lt;/code&gt; identifiers designating what kind
of identifier it refers to. As an example whenever we provision or query VPCs
we can wrap the basic string identifier that AWS returns back as a specific
type &lt;code&gt;VpcId&lt;/code&gt;. This will not allocate a boxed value but will uniquely identify
the type of &lt;code&gt;String&lt;/code&gt; at compile-time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; class VpcId (private val id: String) extends AnyVal
defined class VpcId

scala&amp;gt; class DhcpOptionsId private (val id: String) extends AnyVal
defined class DhcpOptionsId

scala&amp;gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[DhcpOptionsId],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&amp;gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: VpcId,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to make sure the functions provisioning or querying and returning
these identifiers return the appropriate wrapper values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; // Note we are returning VpcId not String any more
     | def provisionVpc(vpc: Vpc): VpcId = ???
provisionVpc: (vpc: Vpc)VpcId

scala&amp;gt; def defaultDhcpOptions(region: Region): DhcpOptionsId = ???
defaultDhcpOptions: (region: Region)DhcpOptionsId
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will be able to see from the type signature something is amiss if we
are returning a &lt;code&gt;VpcId&lt;/code&gt; from a function named &lt;code&gt;defaultDhcpOptions&lt;/code&gt;. Obviously
that isn’t the level of sanity checking we are aiming for, but it’s a reason-
able start for this session.&lt;/p&gt;

&lt;p&gt;You’ll note that we haven’t addressed the problem (yet) that we can simply
construct invalid &lt;code&gt;VpcId&lt;/code&gt; values by passing in illegal format of &lt;code&gt;String&lt;/code&gt;
value to the value class constructor. This will be addressed by a couple of
different techniques in future tutorials. Just know that we will be returning
to this. Promise. :)&lt;/p&gt;

&lt;p&gt;We could also replace the type alias for &lt;code&gt;Prefix&lt;/code&gt; with a value class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;scala&amp;gt; class Prefix (val b: Byte) extends AnyVal
defined class Prefix

scala&amp;gt; object Prefix {
     |   private def isValid(b: UByte): Boolean =
     |     (b &amp;lt;= UByte(32) &amp;amp;&amp;amp; b &amp;gt;= UByte(0))
     | 
     |   def apply(b: UByte): Option[Prefix] =
     |     if (isValid(b)) Some(new Prefix(b.toByte)) else None
     | }
defined object Prefix
warning: previously defined class Prefix is not a companion to object Prefix.
Companions must be defined together; you may wish to use :paste mode for this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The purpose of this initial tutorial was to introduce the reader to the
utility of types generally and specifically how to start to make your APIs
more type safe in Scala using non-structural techniques.&lt;/p&gt;

&lt;p&gt;Hopefully we can take away a sense of purpose in types. They don’t have to be
source code annotations that just add more code bloat, they can add
enormous &lt;em&gt;value&lt;/em&gt; (yes, I couldn’t resist the pun). You might also have noted
that we have gone quite far with types, yet we can still do more to limit
the values we construt in our code to be only valid ones. How far can we take
this? How far makes sense? Keep these questions in mind.&lt;/p&gt;

&lt;p&gt;The next tutorial in the series will walk through how we add some structure
to our types with accompanying functions with specific properties we can
use to reason about our code in more abstract ways.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;Two coworkers were kind enough to offer technical and editing advice for this
tutorial. They are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/trane&quot;&gt;Andrew Kuhnhausen&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/petercaswell&quot;&gt;Peter Caswell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    

  </channel>
</rss>
