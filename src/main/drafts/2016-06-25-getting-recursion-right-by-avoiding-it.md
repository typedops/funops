---
layout: post
title: Getting Recursion Right By Avoiding It
date: 2016-05-25 19:50 -0500
category: tutorials
tags:
  - recursion
  - types
  - algorithms
---

In many popular programming languages (mostly imperative side-effecting
languages) used in industry today, recursion is typically something we are
taught from an early point in our programming ventures to avoid. Instead the
construct we are told to use is iteration. Something like the following:

```tut
object IterationExample extends App {
  def myFun[A](a: A): A = a

  val values: List[Int] = 1 :: 2 :: 3 :: 4 :: 5 :: Nil
  val iterator: Iterator[Int] = values.iterator

  while (iterator.hasNext) {
    println(myFun(iterator.next))
  }
}
```

The most common reasons for avoiding recursion in imperative by default
languages like Java, C#, C++, C, Ruby, Python, etc. relate to the overhead
involved in calling a function/method in the first place, namely a new stack
frame is created so that:

* the arguments supplied to the called function are copied to (when passed
  by-value)
* local variables are stores and manipulated as needed
* result computed (if any is returned) is stored

When using recursive algorithms, it is possible (and often likely) that the
stack frames generated by calling itself will overflow the stack due to needed
depth of computation. A common compiler optimisation used in many functional
or partially functional languages to assist with a common case of recursive
algorithm, _tail calling_, is available. This is where a new stack frame is
not created if the call to itself is in the _tail position_. Here are some
examples and an counter example:

```tut

/** counter example */
import scala.annotation.tailrec

def counterExample0(i: Int): Int = i match {
  case 0 => i
  // Note: * operation is called after the call to itself
  case n => n*counterExample0(n-1)
}

@tailrec
def example0(i: Int, acc: Int): Int = i match {
  case 0 => acc
  case n => example0(n-1, acc+n)
}

@tailrec
def example1(i: Int, acc: Int): Int = i match {
  case 0 => acc
  case n => example1(n-1, acc*n)
}
```

Languages that possess this include Erlang, Scala (with annotations), and
Haskell (where not all calls result in a stack frame created regardless of
tail position).

However, we saw in a prior blog post on 'Why Types?' that our ability to
express our types and value level definitions in a more mathematical form
allowed us to eliminate classes of bugs and problems from our original code.

Recursion is a technique used in much of mathematics. It allows us to use
(proof by) induction to _prove_ properties such as whether it always
terminates (i.e. whether it is total) among other things. In computability
theory these notions are important and in a practical sense it would be great
to know that by construction (or definition) our algorithm actually (a)
terminates and (b) has a total definition for all possible input values. This
allows us to worry about the behavior of other parts of our system.

We could rely on the developers of a project to find these problems
(manually), refactor the code appropriately without types, and then rely on
high levels of team discipline to maintain that code appropriately.

Alternatively my stance is that it would be better to rely to a much larger
degree on a compiler of a language (not necessarily exclusively) that
provides an expressive enough type system to encode the requirements of the
data structure itself that can automatically check the majority of the
assertions that relate to the structure of our application data.

I don't suggest this allows you to throw discipline out the window. You still
need discipline across your team, but perhaps members of your team can focus
their energies on other areas where there isn't a mechanical process
available to provide them with timesaving and higher assurance methods.

## Recursive Definitions Refresher

Let's look at some algorithms using recursive definitions. We will then
manually convert to an iteration based implementation, then we will compare
approaches.

### Structure of a recursive function

Total recursive functions follow the following structure:

* one or more recursive clauses: this is the part that calls itself. This
  clause must always make progress towards the terminating clause in such a
  way to not skip it, so that it will always terminate (i.e. always be total).
* one or more terminating clauses (aka base cases): this is where the function returns
  a value to the caller.

The typical example is fibonacci:

```tut

def fibonacci(n: Int): Option[Int] = n match {
  case 0 => Option(1)
  case 1 => Option(1)
  case n if n > 0 =>
    for { f0 <- fibonacci(n-1)
          f1 <- fibonacci(n-2)
        } yield (f0 + f1)
  case _ => None
}

fibonacci(5)
fibonacci(15)
fibonacci(30)
```

### Example: `isPalindrome`

We will start off easy. A palindrome is a word (a list of characters, loosely)
where the reverse of the given word is the same as itself. Our task is to
define a definition for the function `isPalindrome` that returns a `Boolean`
to signify whether the given _word_ meets property for a palindrome.




