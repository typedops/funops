<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Why Use Types?</title>
  <meta name="description" content="Types are one of the most mainstream and widespread applied formal methodsin software engineering industry today. Yet I have met many accomplished andexperie...">

  <link rel="stylesheet" href="/public/css/main.css">
  <link rel="canonical" href="http://typedops.github.io/tutorials/2015/10/09/why-use-types.html">
  <link rel="alternate" type="application/atom+xml" title="TypedOps" href="http://typedops.github.io/feed.xml" />
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">home</a>
				</li>
			
			
				<li>
					<a href="/archive.html">archive</a>
				</li>
			
			
				<li>
					<a href="/category.html">category</a>
				</li>
			
			
				<li>
					<a href="/tag.html">tag</a>
				</li>
      
		</div>
		<div class="description"> Better infrastructure through types </div>
		<ul class="social-links">
			<li>
				<a href="https://github.com/mbbx6spp" title="Github">
					<img width="19px" height="19px" src="/public/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/public/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/SusanPotter" title="Twitter">
					<img width="19px" height="19px" src="/public/images/twitter.png"/>
				</a>
			</li>
		</ul>
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <article class="single row gutters">
  <time class="published" datetime="2015-10-09">09 October 2015</time>
  <h2>Why Use Types?</h2>

  <p>Types are one of the most mainstream and widespread applied formal methods
in software engineering industry today. Yet I have met many accomplished and
experienced practitioners in our field who do not know how to effectively use
types, even in lanuages they can leverage well for this.</p>

<p>This tutorial is an attempt to show step by step an iterative approach to
transforming what I would consider an ill-typed API (a form I see very often
in operations or infrastructure code) towards a more type-expressive API
which eliminates a large set of invalid values from ever being constructed in
the first place.</p>

<p>This will be the basis for future tutorials that will follow, putting into
practice more structural typed techniques often used in typed functional
programming. My claim here is that pairing a half decent type system that
can express many valid constructions of values (and eliminate many invalid
constructions) with functional programming principles and abstractions we can
build a solid core of a working library or executable. It will allow us to
reason about our code such that we can extend it in ways we previously thought
unimaginable without much heavy lifting (after the initial plumbing work). We
will start to see evidence for this claim in this tutorial post and subsequent
tutorials will build upon this foundation to supply more evidence as we go
along on our journey.</p>

<h2 id="to-the-cloud-and-beyond">To The Cloud And Beyond</h2>

<p>Let’s start out with a simple example. We need to model VPCs and Subnets in
AWS:</p>

<pre><code class="language-scala">scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: String,
     |   dhcpOptionsId: String,
     |   instanceTenancy: String,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: String,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>Now let’s use these definition to construct values:</p>

<pre><code class="language-scala">scala&gt; val region = "us-west-14"
region: String = us-west-14

scala&gt; val vpc = Vpc("10.0.0.0/16", region, null, "dedicated", false)
vpc: Vpc = Vpc(10.0.0.0/16,us-west-14,null,dedicated,false)

scala&gt; val subnet = Subnet("10.10.16.0/24", "sg-123456", s"${region}b", false, false)
subnet: Subnet = Subnet(10.10.16.0/24,sg-123456,us-west-14b,false,false)
</code></pre>

<p>There are a few problems in just this simple usage of these simple classes:</p>

<ol>
  <li>There is no region named <code>us-west-14</code> and the derived availability zone
value is also invalid.</li>
  <li>A <code>null</code> was given for <code>dhcpOptionsId</code> argument but the behavior of various
utilities using these types is unknown when this happens as we don’t know
if they will actually handle <code>null</code>’s properly with defensive programming.</li>
  <li>We might have fat fingered the <code>instanceTenancy</code>, this time we didn’t, but
who knows when everything is just of type <code>String</code>.</li>
  <li>We have no idea if the given <code>cidr</code> block arguments to either <code>Vpc</code> or
<code>Subnet</code> are valid since we just expect a <code>String</code> representing a CIDR.</li>
  <li>We have no idea if the string id for DHCP options or VPC are referring to
identifiers of the right kind or not.</li>
</ol>

<p>We started with such a simple API and already have numerous issues with just
using weak types in our data type definitions.</p>

<p>Now let’s toughen up these types.</p>

<pre><code class="language-scala">scala&gt; // We build a sum type (also called coproduct in some literature)
     | // This is a kind of algebraic data type that represents a logical OR
     | sealed trait Region
defined trait Region

scala&gt; case object UsWest1 extends Region
defined object UsWest1

scala&gt; case object UsWest2 extends Region
defined object UsWest2

scala&gt; case object UsEast1 extends Region
defined object UsEast1

scala&gt; case object EuWest1 extends Region
defined object EuWest1

scala&gt; // Another sum type here for zone *inside* of a region
     | sealed trait Zone
defined trait Zone

scala&gt; case object A extends Zone
defined object A

scala&gt; case object B extends Zone
defined object B

scala&gt; case object C extends Zone
defined object C

scala&gt; // This is a product type (a dressed up N-tuple)
     | // This is another kind of algebraic data type representing logical AND
     | case class AvailabilityZone(region: Region, zone: Zone)
defined class AvailabilityZone

scala&gt; // A sum type to represent the notion of instance tenancy, I am sure I am
     | // missing possible data constructors (the case objects/classes that extend
     | // from the base class, in this case +InstanceTenancy+).
     | sealed trait InstanceTenancy
defined trait InstanceTenancy

scala&gt; case object Dedicated extends InstanceTenancy
defined object Dedicated

scala&gt; case object Default extends InstanceTenancy
defined object Default

scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[String],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>Now we have some provisioning logic that picks the appropriate AWS
credentials when using specific regions vs others:</p>

<pre><code class="language-scala">scala&gt; // we are just mocking out this function for now and not *doing* anything yet
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region == "us-west-1") "vpc-123456" else "vpc-654321"
&lt;console&gt;:23: warning: Region and String are unrelated: they will most likely never compare equal
         if (vpc.region == "us-west-1") "vpc-123456" else "vpc-654321"
                        ^
provisionVpc: (vpc: Vpc)String
</code></pre>

<p>Here we have a problem. The <code>==</code> is always false, but shouldn’t it be a
compiler error instead? In Scala, <code>==</code> takes on the same semantics as
the same operator in Java and thus will always compile even when you
are comparing the value of a different type.</p>

<p>Thankfully in libraries like <code>cats</code> or <code>scalaz</code> (we will be using
<code>cats</code> in these examples) we can use a type safe equality operator
like so:</p>

<pre><code class="language-scala">scala&gt; import cats._, cats.std.all._, cats.syntax.all._
import cats._
import cats.std.all._
import cats.syntax.all._

scala&gt; implicit val regionEquality = new Eq[Region] {
     |   def eqv(r1: Region, r2: Region): Boolean = r1 == r2
     | }
regionEquality: cats.Eq[Region] = $anon$1@7193745d
</code></pre>

<p>It may not seem like we have accomplished much here except that when we use
<code>===</code> (the typesafe equality operator) our code will not compile when we
check different types for equality:</p>

<pre><code class="language-scala">scala&gt; // Now reimplement provisionVpc (but this does not compile, which is what we
     | // want!!!)
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === "us-west-1") "vpc-123456" else "vpc-654321"
&lt;console&gt;:34: error: type mismatch;
 found   : String("us-west-1")
 required: Region
         if (vpc.region === "us-west-1") "vpc-123456" else "vpc-654321"
                            ^
</code></pre>

<p>The following will compile and is exactly what we want in our case:</p>

<pre><code class="language-scala">scala&gt; // Now reimplement provisionVpc where types on either side of === match such
     | // that this now compiles but also the logic behaves as we expect and can
     | // reason about.
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === UsWest1) "vpc-123456" else "vpc-654321"
provisionVpc: (vpc: Vpc)String
</code></pre>

<p>Now we could still improve the constituent types of the <code>Vpc</code> and <code>Subnet</code>
product types further such as accepting a <code>Cidr</code> type for the CIDR block
given:</p>

<pre><code class="language-scala">scala&gt; import spire.math._, spire.implicits._
import spire.math._
import spire.implicits._

scala&gt; // Note: UByte is from spire. It is the most natural type that represents
     | // what we want below without defining a low level type ourselves.
     | // Let me know if I missed something from the standard library that isn't
     | // Byte.
     | 
     | sealed trait IpAddress
defined trait IpAddress

scala&gt; object IpAddress {
     |   private case class Ipv4(a: UByte, b: UByte, c: UByte, d: UByte) extends IpAddress
     |   // TODO: implement Ipv6 when needed
     | 
     |   def apply(a: UByte, b: UByte, c: UByte, d: UByte): IpAddress =
     |     Ipv4(a, b, c, d)
     | }
defined object IpAddress
warning: previously defined trait IpAddress is not a companion to object IpAddress.
Companions must be defined together; you may wish to use :paste mode for this.

scala&gt; // We want an unsigned byte to represent the Prefix (at least for now)
     | type Prefix = UByte
defined type alias Prefix

scala&gt; def prefix(p: UByte): Option[Prefix] =
     |   if (p &lt;= UByte(32) &amp;&amp; p &gt;= UByte(0)) Some(p) else None
prefix: (p: spire.math.UByte)Option[Prefix]

scala&gt; case class Cidr(ip: IpAddress, prefix: Prefix)
defined class Cidr
</code></pre>

<p>So far we have addressed 1 through 4 of the list of problems we identified
above. Let’s recap what we did:</p>

<ol>
  <li>We encoded the notion of region as a sum type and changed the type used
from <code>String</code> to <code>Region</code>. We have eliminated a large number of possible
invalid values from being used in it’s place such that non-existent AWS
regions referenced would not even compile.</li>
  <li>We encoded in our type signature for the <code>Vpc</code> product type (case class)
that we do not require DHCP options identifier to construct a valid <code>Vpc</code>
value. This will inform implementers of functions that use this value that
this field is an optional value so they can plan accordingly.</li>
  <li>We encoded the notion of instance tenancy as a sum type and switched from
using a <code>String</code> to represent the possible values of it to this new type,
<code>InstanceTenancy</code>. The compiler will not catch any fat fingering we may
have made. Think of the potential troubleshooting and debugging time we
gained back from this simple act.</li>
  <li>We have encoded a more meaningful representation for CIDR values that will
limit the possible values to valid basic constructions. A <code>String</code> value
gives us know structure to verify and the validation logic on a <code>String</code>
value for the CIDR case would be error prone and complex without decomposing
into the structural elements of the value in the first place. Even using
regular expressions to validate a <code>String</code> representing a CIDR requires us
to decompose the value into its elements (plus it might not be very
efficient but that is a secondary concern). :)</li>
</ol>

<p>Now we can tackle referential consistency of our string ids via a construct
in Scala called value classes. This allows us to enforce type safety at
compile-time without the runtime allocation overhead.</p>

<p>For our purposes we will wrap up <code>String</code> identifiers designating what kind
of identifier it refers to. As an example whenever we provision or query VPCs
we can wrap the basic string identifier that AWS returns back as a specific
type <code>VpcId</code>. This will not allocate a boxed value but will uniquely identify
the type of <code>String</code> at compile-time.</p>

<pre><code class="language-scala">scala&gt; class VpcId (private val id: String) extends AnyVal
defined class VpcId

scala&gt; class DhcpOptionsId private (val id: String) extends AnyVal
defined class DhcpOptionsId

scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[DhcpOptionsId],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: VpcId,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>We also need to make sure the functions provisioning or querying and returning
these identifiers return the appropriate wrapper values.</p>

<pre><code class="language-scala">scala&gt; // Note we are returning VpcId not String any more
     | def provisionVpc(vpc: Vpc): VpcId = ???
provisionVpc: (vpc: Vpc)VpcId

scala&gt; def defaultDhcpOptions(region: Region): DhcpOptionsId = ???
defaultDhcpOptions: (region: Region)DhcpOptionsId
</code></pre>

<p>Now we will be able to see from the type signature something is amiss if we
are returning a <code>VpcId</code> from a function named <code>defaultDhcpOptions</code>. Obviously
that isn’t the level of sanity checking we are aiming for, but it’s a reason-
able start for this session.</p>

<p>You’ll note that we haven’t addressed the problem (yet) that we can simply
construct invalid <code>VpcId</code> values by passing in illegal format of <code>String</code>
value to the value class constructor. This will be addressed by a couple of
different techniques in future tutorials. Just know that we will be returning
to this. Promise. :)</p>

<p>We could also replace the type alias for <code>Prefix</code> with a value class:</p>

<pre><code class="language-scala">scala&gt; class Prefix (val b: Byte) extends AnyVal
defined class Prefix

scala&gt; object Prefix {
     |   private def isValid(b: UByte): Boolean =
     |     (b &lt;= UByte(32) &amp;&amp; b &gt;= UByte(0))
     | 
     |   def apply(b: UByte): Option[Prefix] =
     |     if (isValid(b)) Some(new Prefix(b.toByte)) else None
     | }
defined object Prefix
warning: previously defined class Prefix is not a companion to object Prefix.
Companions must be defined together; you may wish to use :paste mode for this.
</code></pre>

<p>The purpose of this initial tutorial was to introduce the reader to the
utility of types generally and specifically how to start to make your APIs
more type safe in Scala using non-structural techniques.</p>

<p>Hopefully we can take away a sense of purpose in types. They don’t have to be
source code annotations that just add more code bloat, they can add
enormous <em>value</em> (yes, I couldn’t resist the pun). You might also have noted
that we have gone quite far with types, yet we can still do more to limit
the values we construt in our code to be only valid ones. How far can we take
this? How far makes sense? Keep these questions in mind.</p>

<p>The next tutorial in the series will walk through how we add some structure
to our types with accompanying functions with specific properties we can
use to reason about our code in more abstract ways.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Two coworkers were kind enough to offer technical and editing advice for this
tutorial. They are:</p>

<ul>
  <li><a href="https://github.com/trane">Andrew Kuhnhausen</a></li>
  <li><a href="https://twitter.com/petercaswell">Peter Caswell</a></li>
</ul>


  <p>
  Blog post sponsored by <a href="http://referentiallabs.com">Referential Labs</a>,
  and written by <a href="https://twitter.com/SusanPotter">Susan Potter</a>.
  </p>

</article>


      </div>
    </div>

    
<div>

<!--
<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
-->
<style type="text/css">
#mc_embed_signup {
  background:#fff;
  clear:left;
  font-size:14px;
  width: 480px;
  text-align: center;
  margin: auto;
}
</style>
<div id="mc_embed_signup">
  <form action="//gmail.us13.list-manage.com/subscribe/post?u=9f637599198f6295f84f3845d&amp;id=e7adfc802a&SOURCEURL=http://typedops.github.io/tutorials/2015/10/09/why-use-types.html&SOURCE=http://typedops.github.io" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
      <label for="mce-EMAIL">Subscribe for a monthly tip from Referential Labs on building more reliable distributed systems</label>
      <div>
      <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
      <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
      </div>
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_9f637599198f6295f84f3845d_e7adfc802a" tabindex="-1" value=""></div>
    </div>
  </form>
</div>

</div>

<footer class="footer">

  <p>
    Copyright &copy; 2015-2016
    <a href="https://twitter.com/SusanPotter">@SusanPotter</a> and
    <a href="https://twitter.com/referentiallabs">@referentiallabs</a>.
  </p>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80008235-2', 'auto');
  ga('send', 'pageview');
</script>


  </body>

</html>
